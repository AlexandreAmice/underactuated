<!DOCTYPE html>

<html>

  <head>
    <title>Underactuated Robotics: System Identification</title>
    <meta name="Underactuated Robotics: System Identification" content="text/html; charset=utf-8;" />
    <link rel="canonical" href="http://underactuated.mit.edu/sysid.html" />

    <script src="https://hypothes.is/embed.js" async></script>
    <script type="text/javascript" src="htmlbook/book.js"></script>

    <script src="htmlbook/mathjax-config.js" defer></script> 
    <script type="text/javascript" id="MathJax-script" defer
      src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js">
    </script>
    <script>window.MathJax || document.write('<script type="text/javascript" src="htmlbook/MathJax/es5/tex-chtml.js" defer><\/script>')</script>

    <link rel="stylesheet" href="htmlbook/highlight/styles/default.css">
    <script src="htmlbook/highlight/highlight.pack.js"></script> <!-- http://highlightjs.readthedocs.io/en/latest/css-classes-reference.html#language-names-and-aliases -->
    <script>hljs.initHighlightingOnLoad();</script>

    <link rel="stylesheet" type="text/css" href="htmlbook/book.css" />
  </head>

<body onload="loadChapter('underactuated');">

<div data-type="titlepage">
  <header>
    <h1><a href="index.html" style="text-decoration:none;">Underactuated Robotics</a></h1>
    <p data-type="subtitle">Algorithms for Walking, Running, Swimming, Flying, and Manipulation</p> 
    <p style="font-size: 18px;"><a href="http://people.csail.mit.edu/russt/">Russ Tedrake</a></p>
    <p style="font-size: 14px; text-align: right;"> 
      &copy; Russ Tedrake, 2021<br/>
      Last modified <span id="last_modified"></span>.</br>
      <script>
      var d = new Date(document.lastModified);
      document.getElementById("last_modified").innerHTML = d.getFullYear() + "-" + (d.getMonth()+1) + "-" + d.getDate();</script>
      <a href="misc.html">How to cite these notes, use annotations, and give feedback.</a><br/>
    </p>
  </header>
</div>

<p><b>Note:</b> These are working notes used for <a
href="http://underactuated.csail.mit.edu/Spring2021/">a course being taught
at MIT</a>. They will be updated throughout the Spring 2021 semester.  <a 
href="https://www.youtube.com/channel/UChfUOAhz7ynELF-s_1LPpWg">Lecture  videos are available on YouTube</a>.</p> 

<table style="width:100%;"><tr style="width:100%">
  <td style="width:33%;text-align:left;"><a class="previous_chapter" href=contact.html>Previous Chapter</a></td>
  <td style="width:33%;text-align:center;"><a href=index.html>Table of contents</a></td>
  <td style="width:33%;text-align:right;"><a class="next_chapter" href=state_estimation.html>Next Chapter</a></td>
</tr></table>


<!-- EVERYTHING ABOVE THIS LINE IS OVERWRITTEN BY THE INSTALL SCRIPT -->
<chapter style="counter-reset: chapter 17"><h1>System Identification</h1>
  <a style="float:right; margin-top:-80px;" target="sysid" href="https://colab.research.google.com/github/RussTedrake/underactuated/blob/master/sysid.ipynb"><img src="https://colab.research.google.com/assets/colab-badge.svg" alt="Open Corresponding Notebook In Colab"/></a>
  <div style="clear:right;"></div>

  <p>My primary focus in these notes has been to build algorithms that design
  of analyze a control system <i>given a model</i> of the plant.  In fact, we
  have in some places gone to great lengths to understand the structure in our
  models (the structure of the manipulator equations in particular) and tried
  to write algorithms which exploit that structure.</p>

  <p>Our ambitions for our robots have grown over recent years to where it
  makes sense to question this assumption.  If we want to program a robot to
  fold laundry, spread peanut butter on toast, or make a salad, then we should
  absolutely not assume that we are simply given a model (and the ability to
  estimate the state of that model).  This has led many researchers to focus on
  the "model-free" approaches to optimal control that are popular in
  reinforcement learning.  But I worry that the purely model-free approach is
  "throwing the baby out with the bathwater".  We have fantastic tools for
  making long-term decisions given a model; the model-free approaches are
  correspondingly much much weaker.</p>

  <p>So in this chapter I would like to cover the problem of learning a model.
  This is far from a new problem.  The field of "system identification" is as
  old as controls itself, but new results from machine learning have added
  significantly to our understanding (especially in the high-dimensional and
  finite-sample regimes) and to our algorithmic capabilities.  Making a proper
  contribution to the relatively mature field of system identification has
  traditionally required a thorough statistical analysis of any new algorithm.
  For instance, we might want to prove that the estimate will be unbiased and
  have asymptotic convergence guarantees. I will provide some pointers but
  won't try to provide the full statistical viewpoint here.</p>

  <section><h1>Problem formulation: equation error vs simulation error</h1>
  
    <figure><img width="80%"" src="data/sysid.svg"/></figure>

    <p>Our problem formulation inevitably begins with the data.  In practice,
    if we have access to a physical system, instrumented using digital
    electronics, then we have a system in which we can apply input commands,
    $\bu_n$, at some discrete rate, and measure the outputs, $\by_n$ of the
    system at some discrete rate.  We normally assume these rates our fixed,
    and often attempt to fit a state-space model of the form \begin{equation}
    \bx[n+1] = f_\balpha(\bx[n], \bu[n]), \qquad \by[n] =
    g_\balpha(\bx[n],\bu[n]), \label{eq:ss_model}\end{equation} where I have
    used $\balpha$ again here to indicate a vector of parameters.  In this
    setting, a natural formulation is to minimize a least-squares estimation
    objective: $$\min_{\alpha,\bx[0]} \sum_{n=0}^{N-1} \| \by[n] - \by_n
    \|^2_2, \qquad \subjto \, (\ref{eq:ss_model}).$$  I have written purely
    deterministic models to start, but in general we expect both the state
    evoluation and the measurements to be random variables.  Sometimes, as I
    have written, we fit a deterministic model to the data and rely on our
    least-squares objective to capture the errors; more generally we will look
    at fitting stochastic models to the data.</p>
    
    <p>We often separate the identification procedure into two parts, were we
    first estimate the state $\hat{\bx}_n$ given the input-output data $\bu_n,
    \by_n$, and then focus on estimating the state-evolution dynamics in a
    second step.  The dynamics estimation algorithms fall into two main
    categories: <ul><li><i>Equation error</i> minimizes only the one-step
    prediction error: $$\min_{\alpha} \sum_{n=0}^{N-2} \| f_\balpha(\hat\bx_n,
    \bu_n) - \hat{\bx}_{n+1} \|^2_2.$$  </li><li><i>Simulation error</i>
    captures the long-term prediction error: $$\min_{\alpha} \sum_{n=1}^{N-1}
    \| \bx[n] - \hat{\bx}_n \|^2_2, \qquad \subjto \quad \bx[n+1] =
    f_\balpha(\bx[n], \bu_n), \bx[0] = \hat\bx_0,$$ </li></ul>  The
    equation-error formulations often result in much more tractable
    optimization problems, but unfortunately we will see that optimizing the
    one-step error can still result in arbitrarily large simulation errors.
    Therefore, we generally consider the simulation error to be the true
    objective we hope to optimize, and the equation error only as a potentially
    useful surrogate.</p>
  
  </section>

  <section><h1>Parameter Identification for Mechanical Systems</h1>

    <p>My primary focus throughout these notes is on (underactuated) mechanical
    systems, but when it comes to identification there is an important
    distinction to make.  For some mechanical systems we know the structure of
    the model, including number of state variables and the topology of the
    kinematic tree.  Legged robots like Spot or Atlas are good examples here --
    the dynamics are certainly nontrivial, but the general form of the
    equations are known.  In this case, the task of identification is really
    the task of estimating the parameters in a structured model.  That is the
    subject of this section.</p>

    <p>The examples of folding laundry or making a salad fall into a different
    category.  In those examples, I might not even know a priori the number of
    state variables needed to provide a reasonable description of the behavior.
    That will force a more general examination of the the identification
    problem, which we will explore in the remaining sections.</p>

    <p>Let's start with the problem of identifying a canonical underactuated
    mechanical system, like an Acrobot, Cart-Pole or Quadrotor, where we know
    the structure of the equations, but just need to fit the parameters.  We
    will further assume that we have the ability to directly observe all of the
    state variables, albeit with noisy measurements (e.g. from joint sensors
    and/or inertial measurement units).  The stronger state estimation
    algorithms that we will discuss <a href="state_estimation.html">soon</a>
    assume a model, so we typically do not use them directly here.</p>

    <p>Consider taking a minute to review the <a
    href="multibody.html#double_pendulum">example of deriving the manipulator
    equations for the double pendulum</a> before we continue.</p>

    <subsection><h1>Kinematic parameters and calibration</h1>

      <p>We can separate the parameters in the multibody equations again into
      kinematic parameters and dynamic parameters.  The kinematic parameters,
      like link lengths, describe the coordinate transformation from one joint
      to another joint in the kinematic tree.  It is certainly possible to
      write an optimization procedure to calibrate these parameters; you can
      find a fairly thorough discussion in e.g. Chapter 11 of
      <elib>Khalil04</elib>. But I guess I'm generally of the opinion that if
      you don't have accurate estimates of your link lengths, then you should
      probably invest in a tape measure before you invest in nonlinear
      optimization.</p>

      <p>One notable exception to this is calibration with respect to joint
      offsets.  This one can be a real nuisance in practice.  Joint sensors can
      slip, and some robots even use relative rotary encoders, and rely on
      driving the joint to some known hard joint limit each time the robot is
      powered on in order to obtain the offset.  I've worked on one humanoid
      robot that had a quite elaborate and painful kinematic calibration
      procedure which involve fitting additional hardware over the joints to
      ensure they were in a known location and then running a script.  Having a
      an expensive and/or unreliable calibration procedure can put a damper on
      any robotics project.  For underactuated systems, in particular, it can
      have a dramatic effect on performance.</p>
    
      <example><h1>Acrobot balancing with calibration error</h1>
      
        <p>Small kinematic calibration errors can lead to large steady-state
        errors when attempting to stabilize a system like the Acrobot...</p>

        <p><a target="sysid"
          href="https://colab.research.google.com/github/RussTedrake/underactuated/blob/master/sysid.ipynb#scrollTo=ASlp7CDoQL5t"><img
          src="https://colab.research.google.com/assets/colab-badge.svg"
          alt="Open In Colab"/></a>
            </p>

        <p>Our tools from robust / stochastic control are well-suited to
        identifying (and bounding / minimizing) these sensitivities, at least
        for the linearized model we use in LQR.</p>
      </example>

      <p>The general approach to estimating joint offsets from data is to write
      the equations with the joint offset as a parameter, e.g. for the <a
      href="multibody.html#double_pendulum">double pendulum</a> we would write
      the forward kinematics as:  $${\bf p}_1 =l_1\begin{bmatrix} \sin(\theta_1
      + \bar\theta_1) \\ - \cos(\theta_1 + \bar\theta_1) \end{bmatrix},\quad
      {\bf p}_2  =      {\bf p}_1 + l_2\begin{bmatrix} \sin(\theta_1 +
      \bar\theta_1 + \theta_2 + \bar\theta_2) \\ - \cos(\theta_1 + \bar\theta_1
      + \theta_2 + \bar\theta_2) \end{bmatrix}.$$  We try to obtain independent
      measurements of the end-effector position (e.g. from motion capture, from
      perhaps some robot-mounted cameras, or from some mechanical calibration
      rig) with their corresponding joint measurements, to obtain data points
      of the form $ \langle {\bf p}_2, \theta_1, \theta_2 \rangle$. Then we can
      solve a small nonlinear optimization problem to estimate the joint
      offsets to minimize a least-squares residual.</p>

      <p>If independent measurements of the kinematics are not available, it it
      possible to estimate the offsets along with the dynamic parameters, using
      the trigonometric identities, e.g. $s_{\theta + \bar\theta} = s_\theta
      c_\bar\theta + c_\theta s_\bar\theta,$ and then including the
      $s_\bar\theta, c_\bar\theta$ terms (separately) in the "lumped
      parameters" we discuss below.</p>

    </subsection>

    <subsection><h1>Least-squares formulation (of the inverse dynamics).</h1>

      <example><h1>Multibody parameters in <drake></drake></h1>
      
      </example>

      <p>Lumped parameters.</p>

      <p>Identifiable lumped parameters.</p>

    </subsection>

    <subsection><h1>Power formulations.</h1>
    
      <!-- Great question!  I should have been more careful with my words.  A more accurate statement would have been "rather than do finite differences in joint velocities, we can do finite differences in energy which is more numerically robust".  

      I haven't gotten to writing this part of the notes yet, but hope to catch up soon.  The approach I was describing is from https://ieeexplore.ieee.org/abstract/document/619069 .
      -->

    </subsection>

    <todo>Adaptive control (for underactuated; e.g. Joe Moore's paper Moore14)</todo>

    <todo>Patrick Wensing's inertia identification constraints</todo>

    <subsection><h1>Identification with contact</h1></subsection>

  </section>

  <section><h1>Linear state-space models</h1>
  
    <subsection><h1>From state observations</h1>
      
      <todo>model-order reduction</todo>
    
    </subsection>

    <subsection><h1>From input-output data</h1>
    
      <todo>Ho-Kalman</todo>
      <todo>Subspace identification</todo>
    
    </subsection>

    <subsection><h1>Adding stability constraints</h1></subsection>

  </section>

  <section><h1>Linear ARMAX models</h1></section>

  <section><h1>Piecewise-affine models / hybrid system i.d.</h1></section>

  <section><h1>Nonlinear system identification</h1>
  
    <todo>Neural Nets / Intuitive physics / etc.</todo>
    <todo>MMT / Jack's work</todo>
  
  </section>



  <section><h1>Task-relevant models</h1></section>

  <section><h1>Optimal Experiment Design</h1></section>

</chapter>
<!-- EVERYTHING BELOW THIS LINE IS OVERWRITTEN BY THE INSTALL SCRIPT -->

<div id="references"><section><h1>References</h1>
<ol>

<li id=Khalil04>
<span class="author">W Khalil and E Dombre</span>,
<span class="title">"Modeling, Identification and Control of Robots"</span>,Elsevier
, <span class="year">2004</span>.

</li><br>
</ol>
</section><p/>
</div>

<table style="width:100%;"><tr style="width:100%">
  <td style="width:33%;text-align:left;"><a class="previous_chapter" href=contact.html>Previous Chapter</a></td>
  <td style="width:33%;text-align:center;"><a href=index.html>Table of contents</a></td>
  <td style="width:33%;text-align:right;"><a class="next_chapter" href=state_estimation.html>Next Chapter</a></td>
</tr></table>

<div id="footer">
  <hr>
  <table style="width:100%;">
    <tr><td><a href="https://accessibility.mit.edu/">Accessibility</a></td><td style="text-align:right">&copy; Russ
      Tedrake, 2021</td></tr>
  </table>
</div>


</body>
</html>
